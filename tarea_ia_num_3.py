# -*- coding: utf-8 -*-
"""TAREA IA NUM.3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bsdwKyEqO7TFBsWjpQ8NKAIcKwypvMnY

REDES NEURONALES.....

tarea numero #3
"""

import numpy as np #importo numpy

import numpy as np
# Entradas para la neurona

#Se crea una matriz de entradas
X = np.array([
    [0, 0], #Entrada 0,0
    [0, 1], #Entrada 0,1
    [1, 0], #Entrada 1,0
    [1, 1] #Entrada 1,1
])

"""
Salidas:

Cada valor representa una salida diferente, para la primera entrada (0,0) la salida es 0, para la segunda entrada (0,1) la salida es 1,
 para la tercera entrada (1,0) la salida es 1 y para la cuarta entrada (1,1) la salida es 1. Representando una función OR.
"""
Y = np.array([0, 1, 1, 1])


"""
Pesos:
Se añaden los pesos para cada entrada y el umbral.
"""
W = [10, 50]

"""
Umbral:
Umbral para la función de activación, es decir, con qué valor se activa la neurona.

"""

umbral = 2

"""
Se declara una clase para la neurona McCullochPitts.

"""


class McCullochPitts: #Se declara una clase

"""
En la clase de determinan varias funciones, primero tenemos la función de inicialización.
Que inicializa los pesos (weights) y el umbral (umbral).

"""

    def __init__(self, weights, umbral): # Se le pasan los parametros: peso y umbral a la función de inicialización

        self.weights = weights #peso
        self.umbral = umbral #umbraal


"""
Función que realiza la predicción de la neurona. Pasa como parametro la matriz de entradas (X).
Para posteriormente, calcular la suma ponderada de las entradas con los pesos y comparar con el umbral.


"""
    def predict(self, X):

        predictions = []   # Lista vacia que se utilizara para almacenar los valores que prediga la neurona
        for i in range(X.shape[0]): #Para cada uno de los elementos de la matriz de entradas (X) se realizara lo siguiente:
            weighted_sum = np.dot(self.weights, X[i]) #Se calcula el producto punto entre ambos vectores (la primera entrada por el primer peso, más la segunda entrada por el peso dos, así sucesivamente)
            print(f"Input: {X[i]}, Weighted Sum: {weighted_sum}") #Se muestra el resultado
            if weighted_sum >= self.umbral: #Si el resultado de la suma ponderada es mayor o igual al umbral se realiza lo siguiente:
                predictions.append(1) #Se agrega el valor 1 a mi lista vacía que contendrá los valores predichos
            else:
                predictions.append(0) #Si no se cumple la primera condución se agrega un cero a mi lista vacía que contendrá los valores predichos
        return predictions #Nos devuelve la lista con los valores predichos

#Mandamos a llamar nuestra clase  McCullochPitts y generamos el objeto llamado "mpc"
mcp = McCullochPitts(W, umbral)

predictions = mcp.predict(X) #Podemos usar el método predict para ejecutar la predicción de los valores
print("Predictions:", predictions) #Mostramos el resultado

